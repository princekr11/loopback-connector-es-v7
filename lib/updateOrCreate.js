const _ = require('lodash');
const log = require('debug')('loopback:connector:elasticsearch');
// CONSTANTS
const SEARCHAFTERKEY = '_search_after';
const TOTALCOUNTKEY = '_total_count';

function updateOrCreate(modelName, data, callback) {
  const self = this;
  log('ESConnector.prototype.updateOrCreate', 'modelName', modelName, 'data', data);

  const idName = self.idName(modelName);
  const id = self.getDocumentId(data[idName]);
  if (id === undefined || id === null) {
    throw new Error('id not set!');
  }

  const defaults = self.addDefaults(modelName, 'updateOrCreate');
  // data.docType = modelName;
  if (data[SEARCHAFTERKEY] || data[TOTALCOUNTKEY]) {
    data[SEARCHAFTERKEY] = undefined;
    data[TOTALCOUNTKEY] = undefined;
  }
  self.db.update(_.defaults({
    id,
    body: {
      doc: data,
      doc_as_upsert: true
    }
  }, defaults)).then(({ body }) => {
    /**
     * In the case of an update, elasticsearch only provides a confirmation that it worked
     * but does not provide any model data back. So what should be passed back in
     * the data object (second argument of callback)?
     *   Q1) Should we just pass back the data that was meant to be updated
     *       and came in as an argument to the updateOrCreate() call? This is what
     *       the memory connector seems to do.
     *       A: [Victor Law] Yes, that's fine to do. The reason why we are passing the data there
     *       and back is to support databases that can add default values to undefined properties,
     *       typically the id property is often generated by the backend.
     *   Q2) OR, should we make an additional call to fetch the data for that id internally,
     *       within updateOrCreate()? So we can make sure to pass back a data object?
     *       A: [Victor Law]
     *          - Most connectors don't fetch the inserted/updated data
     *            and hope the data stored into DB
     *            will be the same as the data sent to DB for create/update.
     *          - It's true in most cases but not always. For example, the DB might have triggers
     *            that change the value after the insert/update.
     *            - We don't support that yet.
     *            - In the future, that can be controlled via an options property,
     *              such as fetchNewInstance = true.
     *
     * NOTE: Q1 based approach has been implemented for now.
     */
    // eslint-disable-next-line no-underscore-dangle
    if (body._version === 1) { // distinguish if it was an update or create operation in ES
      // eslint-disable-next-line no-underscore-dangle
      data[idName] = body._id;
      // eslint-disable-next-line no-underscore-dangle
      log('ESConnector.prototype.updateOrCreate', 'assigned ID', idName, '=', body._id);
    }
    callback(null, data, {
      isNewInstance: body.created
    });
  }).catch((error) => {
    log('ESConnector.prototype.updateOrCreate', error.message);
    return callback(error);
  });
}

module.exports.updateOrCreate = updateOrCreate;
